diff --git a/src/Makefile.in b/src/Makefile.in
index a2f7ea011c3..428f3ea5d86 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -447,7 +447,7 @@ .m.o:
 .cc.o:
 	$(AM_V_CXX)$(CXX) -c $(CPPFLAGS) $(ALL_CXX_CFLAGS) $(PROFILING_CFLAGS) $<
 
-base_obj = dispnew.o frame.o scroll.o xdisp.o menu.o $(XMENU_OBJ) window.o     \
+base_obj = dispnew.o frame.o scroll.o xdisp.o cursor-animation.o menu.o $(XMENU_OBJ) window.o     \
 	charset.o coding.o category.o ccl.o character.o chartab.o bidi.o       \
 	$(CM_OBJ) term.o terminal.o xfaces.o $(XOBJ) $(GTK_OBJ) $(DBUS_OBJ)    \
 	emacs.o keyboard.o macros.o keymap.o sysdep.o 			       \
diff --git a/src/cursor-animation.c b/src/cursor-animation.c
new file mode 100644
index 00000000000..52cf99afc17
--- /dev/null
+++ b/src/cursor-animation.c
@@ -0,0 +1,313 @@
+/* Cross-platform cursor animation implementation for GNU Emacs.
+
+Copyright (C) 2025 Free Software Foundation, Inc.
+
+This file is part of GNU Emacs.
+
+GNU Emacs is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or (at
+your option) any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+#include <math.h>
+#include "cursor-animation.h"
+#include "lisp.h"
+#include "frame.h"
+#include "systime.h"
+#include "dispextern.h"
+
+#ifdef HAVE_WINDOW_SYSTEM
+#include TERM_HEADER
+#endif
+
+/* Global animation interface pointer */
+const struct cursor_animation_interface *cursor_animation_interface = NULL;
+
+/* Utility function implementations */
+
+bool
+cursor_should_animate_movement (const struct cursor_animation_state *state,
+                               int new_x, int new_y, int new_width, int new_height,
+                               double current_time)
+{
+  if (!state->last_frame_valid)
+    return true;
+  
+  /* Calculate movement delta */
+  double dx = fabs ((double)(new_x - state->last_frame.x));
+  double dy = fabs ((double)(new_y - state->last_frame.y));
+  double dw = fabs ((double)(new_width - state->last_frame.width));
+  double dh = fabs ((double)(new_height - state->last_frame.height));
+  
+  bool move_delta_big = (dx > CURSOR_MOVE_ON_EPS) || (dy > CURSOR_MOVE_ON_EPS) ||
+                       (dw > CURSOR_MOVE_ON_EPS) || (dh > CURSOR_MOVE_ON_EPS);
+  bool move_delta_small = (dx < CURSOR_MOVE_OFF_EPS) && (dy < CURSOR_MOVE_OFF_EPS) &&
+                         (dw < CURSOR_MOVE_OFF_EPS) && (dh < CURSOR_MOVE_OFF_EPS);
+  
+  /* Determine if currently moving */
+  bool moving;
+  if (!state->last_frame_valid)
+    moving = true;
+  else if (move_delta_big)
+    moving = true;
+  else if (move_delta_small)
+    moving = (current_time - state->last_move_time) < CURSOR_MOVING_GRACE_TIME;
+  else
+    moving = state->visible;
+  
+  return moving;
+}
+
+bool
+cursor_animation_try_reset_blink (void)
+{
+  /* Try to call (blink-cursor--reset) if available */
+  Lisp_Object sym = intern_c_string ("blink-cursor--reset");
+  if (!NILP (Fboundp (sym)))
+    {
+      Ffuncall (1, &sym);
+      return true;
+    }
+  return false;
+}
+
+float
+cursor_animation_get_corner_radius (enum text_cursor_kinds cursor_type)
+{
+  switch (cursor_type)
+    {
+    case BAR_CURSOR:
+    case HBAR_CURSOR:
+      return 0.0f;
+    default:
+      return 1.5f;  /* Box cursors get slight rounding */
+    }
+}
+
+unsigned long
+cursor_animation_get_text_color (unsigned long cursor_bg_color,
+                                struct face *char_face,
+                                struct frame *f)
+{
+  unsigned long text_color;
+  
+  if (char_face)
+    {
+      /* Try character's background color first */
+      text_color = char_face->background;
+      
+      /* If text color matches cursor background (invisible), try foreground */
+      if (text_color == cursor_bg_color)
+        text_color = char_face->foreground;
+      
+      /* If still matching, use frame background as fallback */
+      if (text_color == cursor_bg_color)
+        text_color = FRAME_BACKGROUND_PIXEL (f);
+    }
+  else
+    {
+      /* No face info, use frame background */
+      text_color = FRAME_BACKGROUND_PIXEL (f);
+    }
+  
+  return text_color;
+}
+
+void
+animated_draw_cursor (struct window *w, struct glyph_row *glyph_row,
+                     int x, int y, int width, int height,
+                     enum text_cursor_kinds cursor_type,
+                     bool on_p, bool active_p)
+{
+
+  /* Safety checks for early initialization */
+  if (!w || !glyph_row)
+    return;
+
+  Lisp_Object frame_obj = WINDOW_FRAME (w);
+  if (NILP (frame_obj))
+    return;
+
+  struct frame *f = XFRAME (frame_obj);
+  if (!f || !FRAME_LIVE_P (f))
+    return;
+
+  /* Check if frame has necessary output data */
+#ifdef HAVE_PGTK
+  if (!FRAME_OUTPUT_DATA (f) || !FRAME_GTK_WIDGET (f))
+    return;
+#endif
+
+  /* Only animate in active selected windows */
+  Lisp_Object selected_window = FRAME_SELECTED_WINDOW (f);
+  if (NILP (selected_window))
+    return;
+
+  bool is_selected_window = (w == XWINDOW (selected_window));
+
+  /* IMPORTANT: Only process cursor updates for the selected window.
+     This prevents issues with minibuffer and other windows causing
+     constant window switching detection. */
+  if (!is_selected_window || !active_p)
+    return;
+
+  bool should_animate = true;  /* Always animate in selected, active window */
+
+  /* Get cursor animation state from frame - use a global for now */
+  static struct cursor_animation_state global_state = {0};
+  struct cursor_animation_state *state = &global_state;
+
+  /* Get current time early for window switching logic */
+  double current_time = timespectod (current_timespec ());
+
+  /* If window changed, update tracking but preserve position for smooth animation */
+  if (state->last_window != w)
+    {
+      /* DON'T reset last_frame_valid - we want to animate from old window position!
+         This creates smooth animation when switching between windows. */
+      state->last_move_time = current_time;  /* Mark as just moved to prevent NO_CURSOR from hiding */
+      state->last_window = w;
+
+      /* Reset blink cursor to make it immediately visible in new window */
+      cursor_animation_try_reset_blink ();
+
+      /* Don't clear platform cursor position - preserve it to enable animation
+         from old window position to new window position */
+    }
+
+  /* Handle NO_CURSOR specially BEFORE should_animate check */
+  if (cursor_type == NO_CURSOR)
+    {
+      /* Check if cursor is currently moving - if so, ignore NO_CURSOR to keep cursor visible
+         Check time since last move regardless of last_frame_valid state */
+      double time_since_move = current_time - state->last_move_time;
+      if (time_since_move < CURSOR_MOVING_GRACE_TIME)
+        {
+          /* Cursor is still moving or just stopped - ignore NO_CURSOR to keep it visible */
+          return;
+        }
+
+      if (cursor_animation_interface)
+        cursor_animation_interface->hide_cursor (f);
+      /* Mark cursor as not visible so it will be restored when blink turns on */
+      state->visible = false;
+      return;
+    }
+
+  /* Check if we have the animation interface */
+  if (!cursor_animation_interface)
+    {
+      /* No animation interface available */
+      return;
+    }
+
+  /* Check if cursor type changed */
+  bool cursor_type_changed = (state->last_frame_valid &&
+                              state->last_cursor_type != cursor_type);
+
+  /* Check if we should animate movement */
+  bool should_move = cursor_should_animate_movement (state, x, y, width, height, current_time);
+
+  /* Force update if cursor type changed */
+  if (cursor_type_changed)
+    {
+      should_move = true;
+      /* Invalidate state to force fresh start with new cursor type */
+      state->last_frame_valid = false;
+    }
+
+  /* Force update if cursor was hidden (not visible) but should now be shown
+     This handles the case where blink turns on but position hasn't changed */
+  if (!state->visible && on_p)
+    should_move = true;
+
+  /* Even if cursor isn't moving, we still need to update visibility for blink.
+     When cursor is static but blinking, we need to call update_cursor to sync
+     cursor_visible state even though position/size haven't changed. */
+  bool need_update = should_move;
+
+  if (should_move)
+    {
+      /* Update movement time */
+      state->last_move_time = current_time;
+    }
+
+  /* Always update when cursor should be visible to ensure blink works */
+  if (!need_update && on_p)
+    need_update = true;
+
+  if (need_update)
+    {
+      /* Prepare cursor appearance info */
+      struct cursor_appearance appearance;
+      appearance.cursor_type = cursor_type;
+
+      /* Get cursor color - platform specific */
+#if defined (HAVE_X_WINDOWS)
+      appearance.background_color = f->output_data.x->cursor_pixel;
+#elif defined (HAVE_PGTK)
+      appearance.background_color = FRAME_CURSOR_COLOR (f);
+#elif defined (HAVE_ANDROID)
+      appearance.background_color = f->output_data.android->cursor_pixel;
+#elif defined (HAVE_NS)
+      /* NS uses NSColor object, cannot convert in C file.
+         NS platform will handle color directly in its update_cursor implementation. */
+      appearance.background_color = 0;
+#elif defined (HAVE_HAIKU)
+      appearance.background_color = FRAME_CURSOR_COLOR (f).pixel;
+#else
+      appearance.background_color = 0; /* Default fallback */
+#endif
+
+      appearance.corner_radius = cursor_animation_get_corner_radius (cursor_type);
+      appearance.is_hollow = (cursor_type == HOLLOW_BOX_CURSOR);
+
+      /* Get character info for box cursors */
+      appearance.glyph_info.character = 0;
+      appearance.glyph_info.face = NULL;
+      appearance.glyph_info.is_composite = false;
+      appearance.glyph_info.row_ascent = glyph_row ? glyph_row->ascent : 0;
+
+      if (cursor_type == FILLED_BOX_CURSOR)
+        {
+          struct glyph *cursor_glyph = get_phys_cursor_glyph (w);
+          if (cursor_glyph)
+            {
+              if (cursor_glyph->type == COMPOSITE_GLYPH)
+                appearance.glyph_info.is_composite = true;
+              else if (cursor_glyph->type == CHAR_GLYPH)
+                appearance.glyph_info.character = cursor_glyph->u.ch;
+
+              int face_id = cursor_glyph->face_id;
+              appearance.glyph_info.face = FACE_FROM_ID_OR_NULL (f, face_id);
+            }
+        }
+
+      appearance.foreground_color = cursor_animation_get_text_color (
+        appearance.background_color, appearance.glyph_info.face, f);
+
+      /* Update animated cursor - always animate in selected window */
+      cursor_animation_interface->update_cursor (f, x, y, width, height,
+                                               &appearance, on_p, should_animate);
+
+      /* Update state */
+      state->visible = true;
+      state->last_frame.x = x;
+      state->last_frame.y = y;
+      state->last_frame.width = width;
+      state->last_frame.height = height;
+      state->last_cursor_type = cursor_type;
+      state->last_frame_valid = true;
+    }
+  /* Note: Removed else branch that called hide_cursor when static
+     Let native blink system handle cursor visibility when not moving */
+}
\ No newline at end of file
diff --git a/src/cursor-animation.h b/src/cursor-animation.h
new file mode 100644
index 00000000000..e643b361ac1
--- /dev/null
+++ b/src/cursor-animation.h
@@ -0,0 +1,136 @@
+/* Cross-platform cursor animation system for GNU Emacs.
+
+Copyright (C) 2025 Free Software Foundation, Inc.
+
+This file is part of GNU Emacs.
+
+GNU Emacs is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or (at
+your option) any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef CURSOR_ANIMATION_H
+#define CURSOR_ANIMATION_H
+
+#include "lisp.h"
+#include "frame.h"
+#include "dispextern.h"
+
+INLINE_HEADER_BEGIN
+
+/* Animation parameters - shared across platforms */
+#define CURSOR_MOVE_ON_EPS  0.35   /* Movement threshold to start animation (pixels) */
+#define CURSOR_MOVE_OFF_EPS 0.20   /* Movement threshold to end animation (pixels) */
+#define CURSOR_MOVING_GRACE_TIME 0.12  /* Grace period after stopping (seconds) */
+#define CURSOR_ANIMATION_DURATION 0.10 /* Animation duration (seconds) - matches macOS */
+#define CURSOR_FADE_IN_DURATION 0.06   /* Fade in duration (seconds) */
+
+/* Cross-platform cursor animation state */
+struct cursor_animation_state
+{
+  /* Animation control */
+  bool visible;                    /* Whether animated cursor is visible */
+  bool last_frame_valid;           /* Whether last_frame contains valid data */
+
+  /* Position and geometry */
+  struct {
+    int x, y;                      /* Position in frame coordinates */
+    int width, height;             /* Cursor dimensions */
+  } last_frame;
+
+  /* Cursor type tracking */
+  enum text_cursor_kinds last_cursor_type;  /* Last cursor type */
+
+  /* Timing */
+  double last_move_time;           /* Last movement timestamp */
+
+  /* Window tracking - per frame to detect window switches */
+  struct window *last_window;      /* Last window that had cursor */
+
+  /* Platform-specific data */
+  void *platform_data;             /* Platform-specific animation objects */
+};
+
+/* Cross-platform cursor appearance info */
+struct cursor_appearance
+{
+  enum text_cursor_kinds cursor_type;
+  unsigned long background_color;
+  unsigned long foreground_color;  /* For text on cursor */
+  float corner_radius;
+  bool is_hollow;                  /* For hollow box cursors */
+  
+  /* Character info for box cursors */
+  struct {
+    int character;                 /* Unicode codepoint, 0 if none */
+    struct face *face;             /* Font face for the character */
+    bool is_composite;             /* Whether it's a composite glyph */
+    int row_ascent;                /* Row ascent for baseline calculation */
+  } glyph_info;
+};
+
+/* Platform-specific animation interface */
+struct cursor_animation_interface
+{
+  /* Initialize animation system for a frame */
+  void (*init_animation)(struct frame *f);
+  
+  /* Cleanup animation system for a frame */
+  void (*cleanup_animation)(struct frame *f);
+  
+  /* Update cursor animation with new position/appearance */
+  void (*update_cursor)(struct frame *f, 
+                       int x, int y, int width, int height,
+                       const struct cursor_appearance *appearance,
+                       bool on_state, bool active_window);
+  
+  /* Hide animated cursor (fall back to native drawing) */
+  void (*hide_cursor)(struct frame *f);
+  
+  /* Check if animated cursor is currently visible */
+  bool (*is_cursor_visible)(struct frame *f);
+};
+
+/* Global animation interface - set by platform-specific code */
+extern const struct cursor_animation_interface *cursor_animation_interface;
+
+/* Utility functions for animation logic */
+
+/* Determine if cursor should be animated based on movement delta */
+bool
+cursor_should_animate_movement (const struct cursor_animation_state *state,
+                               int new_x, int new_y, int new_width, int new_height,
+                               double current_time);
+
+/* Try to call Lisp blink-cursor--reset function */
+bool
+cursor_animation_try_reset_blink (void);
+
+/* Calculate corner radius based on cursor type */
+float
+cursor_animation_get_corner_radius (enum text_cursor_kinds cursor_type);
+
+/* Get appropriate text color for cursor overlay */
+unsigned long
+cursor_animation_get_text_color (unsigned long cursor_bg_color,
+                                struct face *char_face,
+                                struct frame *f);
+
+/* Cross-platform cursor animation entry point */
+void
+animated_draw_cursor (struct window *w, struct glyph_row *glyph_row,
+                     int x, int y, int width, int height,
+                     enum text_cursor_kinds cursor_type,
+                     bool on_p, bool active_p);
+
+INLINE_HEADER_END
+
+#endif /* CURSOR_ANIMATION_H */
\ No newline at end of file
diff --git a/src/nsterm.h b/src/nsterm.h
index d9d16ffabd3..98c00fb6e3b 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -461,6 +461,8 @@ #define NSTRACE_UNSILENCE()
 
 @class EmacsToolbar;
 @class EmacsLayer;
+@class CALayer;
+@class CATextLayer;
 
 #ifdef NS_IMPL_COCOA
 @interface EmacsView : NSView <NSTextInput, NSTextInputClient, NSWindowDelegate>
@@ -471,6 +473,13 @@ #define NSTRACE_UNSILENCE()
 #ifdef NS_IMPL_COCOA
   char *old_title;
   BOOL maximizing_resize;
+  NSView  *cursorOverlayView;   /* 与 EmacsView 同坐标系（左上为原点） */
+  CALayer *cursorLayer;         /* 真正绘制"光标块"的 CA 子层 */
+  CATextLayer *cursorTextLayer; /* 光标上显示的文字层 */
+  BOOL cursorLayerVisible;
+  NSRect  cursorLayerLastFrame;   /* 上次目标 frame，用于抑制重复动画 */
+  BOOL    cursorLayerLastValid;   /* 是否已有有效的上次目标 */
+  CFTimeInterval lastMoveT;
 #endif
   BOOL font_panel_active;
   NSFont *font_panel_result;
@@ -505,6 +514,23 @@ #define NSTRACE_UNSILENCE()
 - (void) toggleFullScreen: (id) sender;
 - (BOOL) fsIsNative;
 - (BOOL) isFullscreen;
+
+#ifdef NS_IMPL_COCOA
+- (void)ensureCursorOverlayAndLayer;
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window
+                    cursorType:(enum text_cursor_kinds)cursor_type
+                   glyphString:(NSString *)glyphStr
+                          font:(NSFont *)font
+                 characterFace:(struct face *)face;
+- (void)hideCursorLayer;
+- (BOOL)cursorLayerIsVisible;
+#endif
+
 #if defined (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
 - (void) updateCollectionBehavior;
 #endif
diff --git a/src/nsterm.m b/src/nsterm.m
index 66b4a3c82e7..54e2661ecca 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -71,6 +71,12 @@ Updated by Christian Limpach (chris@nice.ch)
 #include "macfont.h"
 #include <Carbon/Carbon.h>
 #include <IOSurface/IOSurface.h>
+#import <QuartzCore/QuartzCore.h>   /* CALayer, CABasicAnimation, CAMediaTimingFunction */
+#include "lisp.h"
+#include "frame.h"
+static const CGFloat MOVE_ON_EPS  = 0.35;   // 开始移动阈值（像素）
+static const CGFloat MOVE_OFF_EPS = 0.20;   // 结束移动阈值（像素）
+static const CFTimeInterval MOVING_GRACE_S = 0.12; // 停止后的宽限期
 #endif
 
 static EmacsMenu *dockMenu;
@@ -3184,6 +3190,173 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   /* Prevent the cursor from being drawn outside the text area.  */
   r = NSIntersectionRect (r, ns_row_rect (w, glyph_row, TEXT_AREA));
 
+/* ---------- Cursor overlay (neo-style; glyph-box correct; pixel-snapped; animated) ---------- */
+#ifdef NS_IMPL_COCOA
+  {
+    EmacsView *view = FRAME_NS_VIEW (f);
+    if (view && [view window])
+      {
+        if (![view wantsLayer]) [view setWantsLayer:YES];
+
+        /* 仅允许"活动 frame + 被选中 window"驱动 overlay，避免多 window 抢层 */
+        bool is_selected_win = (w == XWINDOW (FRAME_SELECTED_WINDOW (f)));
+        BOOL overlay_ctx_ok = (active_p && is_selected_win);
+
+        /* 非选中窗口不使用 CALayer，直接跳过避免状态干扰 */
+        if (!overlay_ctx_ok)
+          {
+            /* 非选中窗口不显示光标 */
+            return;
+          }
+
+        /* 1) 用"当前 glyph 盒子"重建 r 的高度 —— 避免 box 光标使用整行高 */
+        /* 但保留 HBAR/BAR 光标的原始高度（可能被 evil-half-cursor 等修改）*/
+        if (cursor_type == FILLED_BOX_CURSOR || cursor_type == HOLLOW_BOX_CURSOR)
+        {
+          int used = glyph_row->used[TEXT_AREA];
+          int hpos = w->phys_cursor.hpos;
+          if (!glyph_row->reversed_p && hpos < 0)           hpos = 0;
+          if ( glyph_row->reversed_p && hpos >= used)       hpos = used - 1;
+
+          if (hpos >= 0 && hpos < used)
+            {
+              struct glyph *g = &glyph_row->glyphs[TEXT_AREA][hpos];
+              int asc = g->ascent;
+              int dsc = g->descent;
+              int glyph_h_px = asc + dsc;
+              if (glyph_h_px < 1) glyph_h_px = 1;
+
+              /* 对于 BOX 光标，使用精确的 glyph 高度而不是整行高度 */
+              /* 参照 HBAR_CURSOR 的逻辑（3187-3189），底部对齐 */
+              int orig_h = r.size.height;  /* 保存原始行高 */
+              if (orig_h > glyph_h_px) {
+                /* 光标高度小于行高时，向下移动使底部对齐 */
+                r.origin.y += (orig_h - glyph_h_px);
+              }
+              r.size.height = glyph_h_px;
+            }
+        }
+
+        /* 2) 设备 scale 与像素对齐 */
+        CGFloat scale = view.window.screen ? view.window.screen.backingScaleFactor : 1.0;
+        NSRect fr = r;
+        fr.origin.x    = floor((fr.origin.x  * scale) + 0.5) / scale;
+        fr.origin.y    = floor((fr.origin.y  * scale) + 0.5) / scale;
+        fr.size.width  = fmax(1.0, floor((fr.size.width  * scale) + 0.5) / scale);
+        fr.size.height = fmax(1.0, floor((fr.size.height * scale) + 0.5) / scale);
+
+        /* 3) 颜色与圆角：bar/hbar 为 0，box 可给轻微圆角 */
+        NSColor *ccolor = FRAME_CURSOR_COLOR (f);
+        CGFloat corner = 0.0;
+        switch (cursor_type)
+          {
+          case BAR_CURSOR:  corner = 0.0; break;
+          case HBAR_CURSOR: corner = 0.0; break;
+          default:          corner = 1.5; break; /* box */
+          }
+
+        /* 获取光标下的字符和字体信息 */
+        NSString *glyphStr = nil;
+        NSFont *cursorFont = nil;
+        struct face *cursorFace = NULL;
+
+        if (cursor_type == FILLED_BOX_CURSOR && phys_cursor_glyph) {
+          /* 获取字符 */
+          if (phys_cursor_glyph->type == CHAR_GLYPH) {
+            int c = phys_cursor_glyph->u.ch;
+            if (c > 0 && c < 0x110000) {  /* 有效的 Unicode 字符 */
+              unichar uc = (unichar)c;
+              if (c < 0x10000) {
+                glyphStr = [NSString stringWithCharacters:&uc length:1];
+              } else {
+                /* 处理 surrogate pairs (emoji 等) */
+                unichar chars[2];
+                c -= 0x10000;
+                chars[0] = 0xD800 + (c >> 10);
+                chars[1] = 0xDC00 + (c & 0x3FF);
+                glyphStr = [NSString stringWithCharacters:chars length:2];
+              }
+            }
+          }
+
+          /* 获取字体 */
+          int face_id = phys_cursor_glyph->face_id;
+          cursorFace = FACE_FROM_ID_OR_NULL (f, face_id);
+          if (cursorFace && cursorFace->font) {
+#ifdef NS_IMPL_GNUSTEP
+            struct nsfont_info *font_info = (struct nsfont_info *)cursorFace->font;
+            if (font_info && font_info->nsfont)
+              cursorFont = font_info->nsfont;
+#else
+            cursorFont = (NSFont *)macfont_get_nsctfont (cursorFace->font);
+#endif
+          }
+
+          /* 回退到 frame 默认字体 */
+          if (!cursorFont) {
+            struct font *frame_font = FRAME_OUTPUT_DATA (f)->font;
+            if (frame_font) {
+#ifdef NS_IMPL_GNUSTEP
+              struct nsfont_info *font_info = (struct nsfont_info *)frame_font;
+              if (font_info && font_info->nsfont)
+                cursorFont = font_info->nsfont;
+#else
+              cursorFont = (NSFont *)macfont_get_nsctfont (frame_font);
+#endif
+            }
+          }
+        }
+
+        /* 4) 更新 overlay（overlay 根层 geometryFlipped = YES，避免 tab-bar 触发 y 偏移） */
+        [view updateCursorLayerFrame:fr
+                               scale:(scale > 0 ? scale : 1.0)
+                               color:ccolor
+                        cornerRadius:corner
+                             onState:on_p
+                            activeWL:overlay_ctx_ok
+                          cursorType:cursor_type
+                         glyphString:glyphStr
+                                font:cursorFont
+                       characterFace:cursorFace];
+        /* 只在 CA 层不可见（光标静止）时回退绘制原始光标，交由原生闪烁处理 */
+        if (![view cursorLayerIsVisible])
+          {
+            ns_focus (f, NULL, 0);
+
+            NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+            [ctx saveGraphicsState];
+            NSRectClip (r);
+
+            [FRAME_CURSOR_COLOR (f) set];
+
+            switch (cursor_type)
+              {
+              case DEFAULT_CURSOR:
+              case NO_CURSOR:
+                break;
+              case FILLED_BOX_CURSOR:
+                [ctx restoreGraphicsState];
+                ns_unfocus (f);
+                draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
+                ns_focus (f, &r, 1);
+                break;
+              case HOLLOW_BOX_CURSOR:
+                [NSBezierPath strokeRect: NSInsetRect (r, 0.5, 0.5)];
+                [ctx restoreGraphicsState];
+                break;
+              case HBAR_CURSOR:
+              case BAR_CURSOR:
+                NSRectFill (r);
+                [ctx restoreGraphicsState];
+                break;
+              }
+
+            ns_unfocus (f);
+          }
+      }
+  }
+#else
+  /* GNUstep: 回退到原有绘制（无动画）。保留最小可用实现。 */
   ns_focus (f, NULL, 0);
 
   NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
@@ -3222,6 +3395,7 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
     }
 
   ns_unfocus (f);
+#endif /* NS_IMPL_COCOA */
 }
 
 
@@ -6824,6 +6998,302 @@ - (void)windowDidEndLiveResize:(NSNotification *)notification
   [self updateFramePosition];
 }
 
+/* === Cursor overlay helpers =================================== */
+- (void)ensureCursorOverlayAndLayer
+{
+  if (cursorOverlayView == nil)
+    {
+      NSView *ov = [[NSView alloc] initWithFrame:self.bounds];
+      [ov setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
+      [ov setWantsLayer:YES];
+
+      CALayer *root = [CALayer layer];
+      /* 关键：让 CA 坐标与 EmacsView 一致（左上为原点），避免 tab-bar/tool-bar 造成的 y 偏移 */
+      root.geometryFlipped = NO;
+      root.masksToBounds   = NO;
+#ifdef NSAppKitVersionNumber10_14
+      root.contentsFormat  = kCAContentsFormatRGBA8Uint;
+#endif
+      ov.layer = root;
+
+      CALayer *cl = [CALayer layer];
+      cl.anchorPoint = CGPointZero;          /* 用 frame 放置 */
+      cl.masksToBounds = YES;
+
+      CGFloat scale = self.window.screen ? self.window.screen.backingScaleFactor : 1.0;
+      cl.contentsScale = (scale > 0 ? scale : 1.0);
+
+      /* 关闭隐式动画，转而在“确实移动时”手动加动画（平滑移动） */
+      NSMutableDictionary *acts = [NSMutableDictionary dictionary];
+      [acts setObject:[NSNull null] forKey:@"position"];
+      [acts setObject:[NSNull null] forKey:@"bounds"];
+      [acts setObject:[NSNull null] forKey:@"opacity"];
+      cl.actions = acts;
+
+      [root addSublayer:cl];
+
+      cursorOverlayView = ov;      /* MRC：不使用 __weak */
+      cursorLayer       = cl;
+      cl.opacity = 0.0f;          /* 初始隐藏 CA 光标 */
+      cursorLayerVisible = NO;    /* 初始不占位，不抑制原始绘制 */
+      cursorLayerLastValid = NO;
+
+      [self addSubview:cursorOverlayView];   /* 置于最上层 */
+      [ov release];
+      /* cl 由 root 持有，不需额外 retain */
+    }
+  else
+    {
+      if (![cursorOverlayView wantsLayer])
+        [cursorOverlayView setWantsLayer:YES];
+      if (cursorOverlayView.layer && !cursorOverlayView.layer.geometryFlipped)
+        cursorOverlayView.layer.geometryFlipped = YES;
+    }
+}
+
+- (void)hideCursorLayer
+{
+  if (cursorLayer)
+    {
+      cursorLayer.opacity = 0.0f;
+    }
+  if (cursorTextLayer)
+    {
+      [cursorTextLayer removeFromSuperlayer];
+      cursorTextLayer = nil;
+    }
+  cursorLayerVisible = NO;
+  cursorLayerLastValid = NO; /* 防止旧缓存让下一帧被误判为"在动" */
+}
+
+/* ---------- 方案 B：回落到原生绘制时重置闪烁 ---------- */
+/* 尝试调用 (blink-cursor--reset)：
+   - 语义：立刻点亮光标，并将“下一次开始闪”的计时从头计算；
+   - 只有当该符号存在且可调用时才调用；
+   - 否则返回 false，让上层采用兜底策略（“强制亮一帧”）。 */
+static bool
+ns_try_call_blink_reset_lisp (void)
+{
+  /* intern_c_string: C 字符串 -> Lisp 符号；Fboundp: 是否有函数定义 */
+  Lisp_Object sym = intern_c_string ("blink-cursor--reset");
+  if (!NILP (Fboundp (sym)))
+    {
+      /* call0: 无参调用。等价于 (blink-cursor--reset) */
+      Ffuncall (1, &sym);
+      return true;
+    }
+  return false;
+}
+
+/* 外部可调用的“小重置钩子”：优先用 Lisp 的 reset；
+   若缺失，则返回 false 让调用方做兜底（保亮一帧）。 */
+static bool
+ns_reset_blink_cursor_for_fallback (void)
+{
+  /* 如果能找到并调用 blink-cursor--reset，就用它（最佳语义）。 */
+  if (ns_try_call_blink_reset_lisp ())
+    return true;
+  /* 没有该符号（不同版本/配置）则交由调用点做 minimal 兜底。 */
+  return false;
+}
+
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window
+                    cursorType:(enum text_cursor_kinds)cursor_type
+                   glyphString:(NSString *)glyphStr
+                          font:(NSFont *)font
+                 characterFace:(struct face *)face
+{
+  [self ensureCursorOverlayAndLayer];
+
+  CALayer *root  = cursorOverlayView.layer;
+  CALayer *layer = cursorLayer;
+
+  /* —— 抗抖参数 —— */
+  static const CGFloat MOVE_ON_EPS  = 0.35;
+  static const CGFloat MOVE_OFF_EPS = 0.20;
+  static const CFTimeInterval MOVING_GRACE_S = 0.12;
+
+  static CFTimeInterval s_lastMoveT = 0.0;
+
+  /* 外观同步 - 处理 HOLLOW vs FILLED 光标 */
+  if (cursor_type == HOLLOW_BOX_CURSOR) {
+    /* HOLLOW 光标：透明背景 + 边框 */
+    layer.backgroundColor = [[NSColor clearColor] CGColor];
+    layer.borderColor = color.CGColor;
+    layer.borderWidth = 1.0;
+  } else {
+    /* FILLED 光标：正常背景 + 无边框 */
+    layer.backgroundColor = color.CGColor;
+    layer.borderWidth = 0.0;
+  }
+  layer.cornerRadius = radius;
+
+  /* 更新或创建 CATextLayer 显示光标下的字符 */
+  if (glyphStr && [glyphStr length] > 0 && cursor_type == FILLED_BOX_CURSOR) {
+    if (!cursorTextLayer) {
+      cursorTextLayer = [CATextLayer layer];
+      cursorTextLayer.anchorPoint = CGPointZero;
+
+      /* 关闭隐式动画 */
+      NSMutableDictionary *acts = [NSMutableDictionary dictionary];
+      [acts setObject:[NSNull null] forKey:@"position"];
+      [acts setObject:[NSNull null] forKey:@"bounds"];
+      [acts setObject:[NSNull null] forKey:@"foregroundColor"];
+      [acts setObject:[NSNull null] forKey:@"contents"];
+      cursorTextLayer.actions = acts;
+
+      [layer addSublayer:cursorTextLayer];
+    }
+
+    /* 设置文字内容 */
+    cursorTextLayer.string = glyphStr;
+    cursorTextLayer.font = (__bridge CFTypeRef)font;
+    cursorTextLayer.fontSize = [font pointSize];
+
+    /* 智能文字颜色选择（参考 X11 xterm.c:8335-8351）*/
+    struct frame *f = *emacsframe;
+    NSColor *textColor = nil;
+    unsigned long cursorBgColor = [color unsignedLong];
+
+    if (face) {
+      /* 1. 优先使用字符原背景色（保留原色效果）*/
+      textColor = [NSColor colorWithUnsignedLong:face->background];
+      unsigned long textColorVal = [textColor unsignedLong];
+
+      /* 2. 如果文字颜色与光标背景色相同（看不清），尝试用前景色 */
+      if (textColorVal == cursorBgColor) {
+        textColor = [NSColor colorWithUnsignedLong:face->foreground];
+        textColorVal = [textColor unsignedLong];
+      }
+
+      /* 3. 如果还是看不清，使用 frame 背景色（反色）*/
+      if (textColorVal == cursorBgColor) {
+        textColor = FRAME_BACKGROUND_COLOR (f);
+      }
+    } else {
+      /* 无 face 信息时，回退到 frame 背景色 */
+      textColor = FRAME_BACKGROUND_COLOR (f);
+    }
+
+    cursorTextLayer.foregroundColor = [textColor CGColor];
+    cursorTextLayer.contentsScale = scale;
+    cursorTextLayer.alignmentMode = kCAAlignmentCenter;
+
+    /* 设置文字层的位置和大小与光标层一致 */
+    cursorTextLayer.position = CGPointZero;
+    cursorTextLayer.bounds = CGRectMake(0, 0, fr.size.width, fr.size.height);
+  } else {
+    /* HOLLOW 光标或无字符时隐藏文字层 */
+    if (cursorTextLayer) {
+      [cursorTextLayer removeFromSuperlayer];
+      cursorTextLayer = nil;
+    }
+  }
+
+  /* 坐标→像素对齐 */
+  CGFloat H_view = NSHeight(self.bounds);
+  fr.origin.y = H_view - fr.size.height - fr.origin.y;
+
+  CGFloat s = (scale > 0 ? scale : 1.0);
+  fr.origin.x    = floor((fr.origin.x  * s) + 0.5) / s;
+  fr.origin.y    = floor((fr.origin.y  * s) + 0.5) / s;
+  fr.size.width  = fmax(1.0, floor((fr.size.width  * s) + 0.5) / s);
+  fr.size.height = fmax(1.0, floor((fr.size.height * s) + 0.5) / s);
+
+  root.contentsScale  = s;
+  layer.contentsScale = s;
+
+  /* 与上一帧差异 */
+  CGFloat dx = fabs(fr.origin.x - cursorLayerLastFrame.origin.x);
+  CGFloat dy = fabs(fr.origin.y - cursorLayerLastFrame.origin.y);
+  CGFloat dw = fabs(fr.size.width  - cursorLayerLastFrame.size.width);
+  CGFloat dh = fabs(fr.size.height - cursorLayerLastFrame.size.height);
+
+  BOOL move_delta_big   = (dx > MOVE_ON_EPS)  || (dy > MOVE_ON_EPS)  ||
+                          (dw > MOVE_ON_EPS)  || (dh > MOVE_ON_EPS);
+  BOOL move_delta_small = (dx < MOVE_OFF_EPS) && (dy < MOVE_OFF_EPS) &&
+                          (dw < MOVE_OFF_EPS) && (dh < MOVE_OFF_EPS);
+
+  CFTimeInterval now = CACurrentMediaTime();
+  BOOL moving;
+  if (!cursorLayerLastValid)      moving = YES;
+  else if (move_delta_big)        moving = YES;
+  else if (move_delta_small)      moving = (now - s_lastMoveT) < MOVING_GRACE_S;
+  else                            moving = cursorLayerVisible;
+
+  if (moving) s_lastMoveT = now;
+
+  /* ================= 移动态：忽略 blink，相位始终亮 ================= */
+  if (moving) {
+    /* 初次变可见：一次性淡入 */
+    if (!cursorLayerVisible) {
+      cursorLayerVisible = YES;
+      layer.opacity = 1.0;
+      CABasicAnimation *fade = [CABasicAnimation animationWithKeyPath:@"opacity"];
+      fade.fromValue = @(0.0);
+      fade.toValue   = @(1.0);
+      fade.duration  = 0.06;
+      fade.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+      [layer addAnimation:fade forKey:@"cursorFadeInOnce"];
+    }
+
+    /* —— 始终做位移/尺寸动画（无大跳变特判）—— */
+    /* 先把最终值写入 model layer */
+    layer.position = fr.origin;
+    layer.bounds   = (CGRect){ .origin={0,0}, .size=fr.size };
+
+    /* 只要有几何变化就加动画；无变化则不必加（避免堆积） */
+    if ((dx + dy + dw + dh) > 0.0) {
+      CALayer *pres = (CALayer *)layer.presentationLayer;
+
+      /* position 动画 */
+      CABasicAnimation *pos = [CABasicAnimation animationWithKeyPath:@"position"];
+      pos.fromValue = pres ? [NSValue valueWithPoint:NSPointFromCGPoint(((CALayer *)pres).position)]
+                           : [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.toValue   = [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.duration  = 0.10;
+      pos.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* bounds 动画（尺寸变化） */
+      CABasicAnimation *bd = [CABasicAnimation animationWithKeyPath:@"bounds"];
+      bd.fromValue = pres ? [NSValue valueWithRect:NSRectFromCGRect(((CALayer *)pres).bounds)]
+                          : [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.toValue   = [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.duration  = 0.10;
+      bd.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* 覆盖同类动画，避免堆积 */
+      [layer addAnimation:pos forKey:@"cursorMovePosition"];
+      [layer addAnimation:bd  forKey:@"cursorMoveBounds"];
+    }
+
+    cursorLayerLastFrame = fr;
+    cursorLayerLastValid = YES;
+    return; /* 移动态不走原生绘制，避免双影 */
+  }
+
+  /* ================= 静止：交回原生闪烁 ================= */
+  layer.opacity       = 0.0;
+  cursorLayerVisible  = NO;
+  if (cursorTextLayer) {
+    [cursorTextLayer removeFromSuperlayer];
+    cursorTextLayer = nil;
+  }
+  cursorLayerLastFrame = fr;
+  cursorLayerLastValid = YES;
+}
+
+- (BOOL)cursorLayerIsVisible
+{
+  return cursorLayerVisible;
+}
+/* ========================================================================== */
+
 /* Needed to inform when window closed from lisp.  */
 - (void) setWindowClosing: (BOOL)closing
 {
diff --git a/src/pgtkterm.c b/src/pgtkterm.c
index a7be2d90899..c87b499be7d 100644
--- a/src/pgtkterm.c
+++ b/src/pgtkterm.c
@@ -26,6 +26,9 @@ Copyright (C) 1989, 1993-1994, 2005-2006, 2008-2025 Free Software
 #endif
 
 #include <cairo.h>
+#include <cairo-ft.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
 #include <fcntl.h>
 #include <math.h>
 #include <pthread.h>
@@ -64,6 +67,7 @@ Copyright (C) 1989, 1993-1994, 2005-2006, 2008-2025 Free Software
 #include "font.h"
 #include "xsettings.h"
 #include "emacsgtkfixed.h"
+#include "cursor-animation.h"
 
 #ifdef GDK_WINDOWING_WAYLAND
 #include <gdk/gdkwayland.h>
@@ -117,6 +121,31 @@ #define FRAME_CR_SURFACE(f)		(cairo_get_target (FRAME_CR_CONTEXT (f)))
 static struct frame *pgtk_any_window_to_frame (GdkWindow *);
 static void pgtk_regenerate_devices (struct pgtk_display_info *);
 
+/* Cursor animation data structure */
+struct pgtk_cursor_animation_data
+{
+  /* Animation state */
+  struct {
+    double start_x, start_y;
+    double target_x, target_y;
+    double start_width, start_height;
+    double target_width, target_height;
+    double current_x, current_y;
+    double current_width, current_height;
+    double start_time;
+    double duration;
+    bool active;
+  } animation;
+
+  /* Visual appearance */
+  struct cursor_appearance last_appearance;
+
+  /* Visibility flag */
+  bool cursor_visible;
+};
+
+static struct pgtk_cursor_animation_data *pgtk_get_cursor_animation_data (struct frame *);
+
 static void
 pgtk_device_added_or_removal_cb (GdkSeat *seat, GdkDevice *device,
 				 gpointer user_data)
@@ -3002,48 +3031,45 @@ pgtk_draw_window_cursor (struct window *w, struct glyph_row *glyph_row, int x,
 	{
 	  glyph_row->cursor_in_fringe_p = true;
 	  draw_fringe_bitmap (w, glyph_row, glyph_row->reversed_p);
+	  return;
 	}
-      else
-	{
-	  switch (cursor_type)
-	    {
-	    case HOLLOW_BOX_CURSOR:
-	      pgtk_draw_hollow_cursor (w, glyph_row);
-	      break;
 
-	    case FILLED_BOX_CURSOR:
-	      draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
-	      break;
+      /* Calculate cursor dimensions */
+      int cursor_height = w->phys_cursor_height;
 
-	    case BAR_CURSOR:
-	      pgtk_draw_bar_cursor (w, glyph_row, cursor_width, BAR_CURSOR);
-	      break;
-
-	    case HBAR_CURSOR:
-	      pgtk_draw_bar_cursor (w, glyph_row, cursor_width, HBAR_CURSOR);
-	      break;
+      /* Handle cursor_width <= 0: use cursor glyph's actual width */
+      if (cursor_width <= 0)
+        {
+          struct glyph *cursor_glyph = get_phys_cursor_glyph (w);
+          if (cursor_glyph)
+            cursor_width = cursor_glyph->pixel_width;
+          else
+            cursor_width = FRAME_COLUMN_WIDTH (f);
+        }
 
-	    case NO_CURSOR:
-	      w->phys_cursor_width = 0;
-	      break;
+      /* Convert TEXT area coordinates to frame coordinates
+         This properly accounts for left fringe, left margin, etc. */
+      int frame_x = WINDOW_TEXT_TO_FRAME_PIXEL_X (w, x);
+      int frame_y = WINDOW_TO_FRAME_PIXEL_Y (w, y);
 
-	    default:
-	      emacs_abort ();
-	    }
-	}
+      /* Call animated cursor drawing with frame coordinates */
+      animated_draw_cursor (w, glyph_row, frame_x, frame_y, cursor_width, cursor_height,
+                           cursor_type, on_p, active_p);
 
+      /* Update input method cursor location */
       if (w == XWINDOW (f->selected_window))
 	{
-	  int frame_x = (WINDOW_TO_FRAME_PIXEL_X (w, x)
-			 + WINDOW_LEFT_FRINGE_WIDTH (w)
-			 + WINDOW_LEFT_MARGIN_WIDTH (w));
-	  int frame_y = WINDOW_TO_FRAME_PIXEL_Y (w, y);
 	  pgtk_im_set_cursor_location (f, frame_x, frame_y,
 				       w->phys_cursor_width,
 				       w->phys_cursor_height);
 	}
     }
-
+  else
+    {
+      /* Cursor off - let animation system handle */
+      animated_draw_cursor (w, glyph_row, 0, 0, 0, 0,
+                           NO_CURSOR, false, active_p);
+    }
 }
 
 static void
@@ -5073,6 +5099,212 @@ pgtk_handle_draw (GtkWidget *widget, cairo_t *cr, gpointer *data)
 	  cairo_set_source_surface (cr, src, 0, 0);
 	  cairo_paint (cr);
 	}
+
+      /* Draw animated cursor if visible */
+      if (f != NULL)
+        {
+          struct pgtk_cursor_animation_data *cursor_data = pgtk_get_cursor_animation_data (f);
+          /* Draw cursor if it has valid dimensions
+             Note: Don't check cursor_visible here - that's for intentional hiding (e.g., NO_CURSOR)
+             The on_state parameter in update_cursor controls blink visibility */
+          if (cursor_data &&
+              cursor_data->animation.current_width > 0 &&
+              cursor_data->animation.current_height > 0)
+            {
+              int x = (int) cursor_data->animation.current_x;
+              int y = (int) cursor_data->animation.current_y;
+              int width = (int) cursor_data->animation.current_width;
+              int height = (int) cursor_data->animation.current_height;
+
+              struct cursor_appearance *appearance = &cursor_data->last_appearance;
+              enum text_cursor_kinds cursor_type = appearance->cursor_type;
+
+              /* Extract RGB from color */
+              unsigned long color = appearance->background_color;
+              double red = RED_FROM_ULONG (color) / 255.0;
+              double green = GREEN_FROM_ULONG (color) / 255.0;
+              double blue = BLUE_FROM_ULONG (color) / 255.0;
+
+              cairo_set_source_rgb (cr, red, green, blue);
+
+              if (cursor_type == BAR_CURSOR)
+                {
+                  /* Draw vertical bar */
+                  int bar_width = (width > 2) ? 2 : width;
+                  cairo_rectangle (cr, x, y, bar_width, height);
+                  cairo_fill (cr);
+                }
+              else if (cursor_type == HBAR_CURSOR)
+                {
+                  /* Draw horizontal bar at bottom of line */
+                  int bar_height = (height > 2) ? 2 : height;
+                  cairo_rectangle (cr, x, y + height - bar_height, width, bar_height);
+                  cairo_fill (cr);
+                }
+              else if (cursor_type == FILLED_BOX_CURSOR)
+                {
+                  /* Draw filled box */
+                  float radius = appearance->corner_radius;
+                  if (radius > 0)
+                    {
+                      /* Rounded rectangle */
+                      cairo_new_path (cr);
+                      cairo_arc (cr, x + radius, y + radius, radius, M_PI, 3 * M_PI / 2);
+                      cairo_arc (cr, x + width - radius, y + radius, radius, 3 * M_PI / 2, 0);
+                      cairo_arc (cr, x + width - radius, y + height - radius, radius, 0, M_PI / 2);
+                      cairo_arc (cr, x + radius, y + height - radius, radius, M_PI / 2, M_PI);
+                      cairo_close_path (cr);
+                      cairo_fill (cr);
+                    }
+                  else
+                    {
+                      cairo_rectangle (cr, x, y, width, height);
+                      cairo_fill (cr);
+                    }
+
+                  /* Draw character on cursor if available */
+                  if (appearance->glyph_info.character > 0 &&
+                      !appearance->glyph_info.is_composite &&
+                      appearance->glyph_info.face)
+                    {
+                      /* Get text color (reverse of cursor background) */
+                      unsigned long text_color = appearance->foreground_color;
+                      double text_red = RED_FROM_ULONG (text_color) / 255.0;
+                      double text_green = GREEN_FROM_ULONG (text_color) / 255.0;
+                      double text_blue = BLUE_FROM_ULONG (text_color) / 255.0;
+
+                      /* Convert Unicode codepoint to UTF-8 */
+                      char utf8[8];
+                      int len = 0;
+                      int c = appearance->glyph_info.character;
+
+                      if (c < 0x80)
+                        {
+                          utf8[len++] = c;
+                        }
+                      else if (c < 0x800)
+                        {
+                          utf8[len++] = 0xC0 | (c >> 6);
+                          utf8[len++] = 0x80 | (c & 0x3F);
+                        }
+                      else if (c < 0x10000)
+                        {
+                          utf8[len++] = 0xE0 | (c >> 12);
+                          utf8[len++] = 0x80 | ((c >> 6) & 0x3F);
+                          utf8[len++] = 0x80 | (c & 0x3F);
+                        }
+                      else if (c < 0x110000)
+                        {
+                          utf8[len++] = 0xF0 | (c >> 18);
+                          utf8[len++] = 0x80 | ((c >> 12) & 0x3F);
+                          utf8[len++] = 0x80 | ((c >> 6) & 0x3F);
+                          utf8[len++] = 0x80 | (c & 0x3F);
+                        }
+                      utf8[len] = '\0';
+
+                      if (len > 0)
+                        {
+                          /* Get font from face */
+                          struct face *face = appearance->glyph_info.face;
+                          if (face && face->font)
+                            {
+                              /* Set text color (reverse of cursor background) */
+                              cairo_set_source_rgb (cr, text_red, text_green, text_blue);
+
+                              /* Try to get font file path for exact font matching */
+                              const char *font_file = NULL;
+                              if (face->font->props != NULL)
+                                {
+                                  Lisp_Object file_obj = face->font->props[FONT_FILE_INDEX];
+                                  if (STRINGP (file_obj))
+                                    font_file = SSDATA (file_obj);
+                                }
+
+                              /* Use font family name as fallback */
+                              const char *family_name = "monospace";
+                              if (face->font->props != NULL)
+                                {
+                                  Lisp_Object font_object = face->font->props[FONT_FAMILY_INDEX];
+                                  if (SYMBOLP (font_object))
+                                    {
+                                      Lisp_Object name = SYMBOL_NAME (font_object);
+                                      if (STRINGP (name))
+                                        {
+                                          const char *name_str = SSDATA (name);
+                                          if (name_str && *name_str)
+                                            family_name = name_str;
+                                        }
+                                    }
+                                }
+
+                              cairo_font_face_t *font_face = NULL;
+
+                              /* Try to load from font file if available */
+                              if (font_file && *font_file)
+                                {
+                                  FT_Library ft_library;
+                                  FT_Face ft_face;
+
+                                  if (FT_Init_FreeType (&ft_library) == 0)
+                                    {
+                                      if (FT_New_Face (ft_library, font_file, 0, &ft_face) == 0)
+                                        {
+                                          font_face = cairo_ft_font_face_create_for_ft_face (ft_face, 0);
+                                          /* Note: ft_face and ft_library will leak, but for cursor
+                                             rendering performance this is acceptable */
+                                        }
+                                    }
+                                }
+
+                              /* Set font - use loaded font face or fallback to family name */
+                              if (font_face)
+                                {
+                                  cairo_set_font_face (cr, font_face);
+                                  cairo_font_face_destroy (font_face);
+                                }
+                              else
+                                {
+                                  cairo_select_font_face (cr, family_name,
+                                                         CAIRO_FONT_SLANT_NORMAL,
+                                                         CAIRO_FONT_WEIGHT_NORMAL);
+                                }
+
+                              /* Set font size from face */
+                              double font_size = face->font->pixel_size;
+                              if (font_size <= 0)
+                                font_size = face->font->height;
+                              if (font_size <= 0)
+                                font_size = 12.0;
+
+                              cairo_set_font_size (cr, font_size);
+
+                              /* Calculate baseline position using row ascent
+                                 In Emacs, baseline = row_y + row_ascent
+                                 This matches native text rendering exactly. */
+                              double baseline_y = y + appearance->glyph_info.row_ascent;
+
+                              /* Measure text for horizontal centering */
+                              cairo_text_extents_t extents;
+                              cairo_text_extents (cr, utf8, &extents);
+
+                              double text_x = x + (width - extents.x_advance) / 2.0;
+
+                              /* Draw the character */
+                              cairo_move_to (cr, text_x, baseline_y);
+                              cairo_show_text (cr, utf8);
+                            }
+                        }
+                    }
+                }
+              else if (cursor_type == HOLLOW_BOX_CURSOR)
+                {
+                  /* Draw hollow box */
+                  cairo_set_line_width (cr, 1.0);
+                  cairo_rectangle (cr, x + 0.5, y + 0.5, width - 1, height - 1);
+                  cairo_stroke (cr);
+                }
+            }
+        }
     }
   return FALSE;
 }
@@ -6985,6 +7217,193 @@ pgtk_selection_event (GtkWidget *widget, GdkEvent *event,
 /* Display a warning message if the PGTK port is being used under X;
    that is not supported.  */
 
+/* Cursor animation support */
+
+static struct pgtk_cursor_animation_data *
+pgtk_get_cursor_animation_data (struct frame *f)
+{
+  if (!f || !FRAME_PGTK_P (f))
+    return NULL;
+
+  struct pgtk_output *output = FRAME_OUTPUT_DATA (f);
+  if (!output->cursor_animation_data)
+    {
+      output->cursor_animation_data = xzalloc (sizeof (struct pgtk_cursor_animation_data));
+      output->cursor_animation_data->cursor_visible = false;
+      output->cursor_animation_data->animation.active = false;
+    }
+
+  return output->cursor_animation_data;
+}
+
+static void
+pgtk_cursor_animation_init (struct frame *f)
+{
+  /* Initialize cursor animation data for the frame */
+  pgtk_get_cursor_animation_data (f);
+}
+
+static void
+pgtk_cursor_animation_cleanup (struct frame *f)
+{
+  if (!f || !FRAME_PGTK_P (f))
+    return;
+
+  struct pgtk_output *output = FRAME_OUTPUT_DATA (f);
+  if (output->cursor_animation_data)
+    {
+      xfree (output->cursor_animation_data);
+      output->cursor_animation_data = NULL;
+    }
+}
+
+/* Animation timer callback */
+static gboolean
+pgtk_cursor_animation_tick (gpointer user_data)
+{
+  struct frame *f = (struct frame *) user_data;
+  if (!f || !FRAME_LIVE_P (f))
+    return G_SOURCE_REMOVE;
+
+  struct pgtk_cursor_animation_data *data = pgtk_get_cursor_animation_data (f);
+  if (!data || !data->animation.active)
+    return G_SOURCE_REMOVE;
+
+  /* Get current time */
+  double current_time = timespectod (current_timespec ());
+  double elapsed = current_time - data->animation.start_time;
+  double progress = elapsed / data->animation.duration;
+
+  if (progress >= 1.0)
+    {
+      /* Animation complete */
+      data->animation.current_x = data->animation.target_x;
+      data->animation.current_y = data->animation.target_y;
+      data->animation.current_width = data->animation.target_width;
+      data->animation.current_height = data->animation.target_height;
+      data->animation.active = false;
+
+      if (FRAME_GTK_WIDGET (f))
+        gtk_widget_queue_draw (FRAME_GTK_WIDGET (f));
+
+      return G_SOURCE_REMOVE;
+    }
+
+  /* Ease-out cubic interpolation (matches macOS kCAMediaTimingFunctionEaseOut) */
+  double t = progress - 1.0;
+  double eased = 1.0 + t * t * t;
+
+  /* Interpolate position and size */
+  data->animation.current_x = data->animation.start_x +
+    (data->animation.target_x - data->animation.start_x) * eased;
+  data->animation.current_y = data->animation.start_y +
+    (data->animation.target_y - data->animation.start_y) * eased;
+  data->animation.current_width = data->animation.start_width +
+    (data->animation.target_width - data->animation.start_width) * eased;
+  data->animation.current_height = data->animation.start_height +
+    (data->animation.target_height - data->animation.start_height) * eased;
+
+  /* Request redraw */
+  if (FRAME_GTK_WIDGET (f))
+    gtk_widget_queue_draw (FRAME_GTK_WIDGET (f));
+
+  return G_SOURCE_CONTINUE;
+}
+
+static void
+pgtk_cursor_animation_update (struct frame *f, int x, int y,
+                               int width, int height,
+                               const struct cursor_appearance *appearance,
+                               bool on_state, bool should_animate)
+{
+  struct pgtk_cursor_animation_data *data = pgtk_get_cursor_animation_data (f);
+  if (!data)
+    return;
+
+  /* Store start position for animation */
+  data->animation.start_x = data->animation.current_x;
+  data->animation.start_y = data->animation.current_y;
+  data->animation.start_width = data->animation.current_width;
+  data->animation.start_height = data->animation.current_height;
+
+  /* Update target position and size */
+  data->animation.target_x = x;
+  data->animation.target_y = y;
+  data->animation.target_width = width;
+  data->animation.target_height = height;
+
+  /* If first time (no valid position) or explicitly not animating, jump to target */
+  bool has_valid_position = (data->animation.current_width > 0 &&
+                             data->animation.current_height > 0);
+
+  if (!has_valid_position || !should_animate)
+    {
+      data->animation.current_x = x;
+      data->animation.current_y = y;
+      data->animation.current_width = width;
+      data->animation.current_height = height;
+    }
+  else
+    {
+      /* Start animation */
+      data->animation.start_time = timespectod (current_timespec ());
+      data->animation.duration = CURSOR_ANIMATION_DURATION;
+      data->animation.active = true;
+
+      /* Start animation timer (60 FPS) */
+      g_timeout_add (16, pgtk_cursor_animation_tick, f);
+    }
+
+  /* Update appearance */
+  if (appearance)
+    data->last_appearance = *appearance;
+
+  /* Update visibility */
+  data->cursor_visible = on_state;
+
+  /* Request frame redraw */
+  if (FRAME_GTK_WIDGET (f))
+    gtk_widget_queue_draw (FRAME_GTK_WIDGET (f));
+}
+
+static void
+pgtk_cursor_animation_hide (struct frame *f)
+{
+  struct pgtk_cursor_animation_data *data = pgtk_get_cursor_animation_data (f);
+  if (!data)
+    return;
+
+  /* Mark cursor as not visible but preserve position
+     This allows smooth animation when cursor reappears (e.g., after blink or window switch) */
+  data->cursor_visible = false;
+  data->animation.active = false;
+
+  /* Request frame redraw */
+  if (FRAME_GTK_WIDGET (f))
+    gtk_widget_queue_draw (FRAME_GTK_WIDGET (f));
+}
+
+static bool
+pgtk_cursor_animation_is_visible (struct frame *f)
+{
+  struct pgtk_cursor_animation_data *data = pgtk_get_cursor_animation_data (f);
+  if (!data)
+    return false;
+
+  return data->cursor_visible &&
+         data->animation.current_width > 0 &&
+         data->animation.current_height > 0;
+}
+
+/* Cursor animation interface registration */
+static const struct cursor_animation_interface pgtk_cursor_anim_interface = {
+  .init_animation = pgtk_cursor_animation_init,
+  .cleanup_animation = pgtk_cursor_animation_cleanup,
+  .update_cursor = pgtk_cursor_animation_update,
+  .hide_cursor = pgtk_cursor_animation_hide,
+  .is_cursor_visible = pgtk_cursor_animation_is_visible
+};
+
 static void
 pgtk_display_x_warning (GdkDisplay *display)
 {
@@ -7260,6 +7679,9 @@ #define NUM_ARGV 10
 		    G_CALLBACK (pgtk_seat_removed_cb), dpyinfo);
   pgtk_enumerate_devices (dpyinfo, true);
 
+  /* Register cursor animation interface */
+  cursor_animation_interface = &pgtk_cursor_anim_interface;
+
   unblock_input ();
 
   return dpyinfo;
diff --git a/src/pgtkterm.h b/src/pgtkterm.h
index 94a40b823c8..6e0928ba948 100644
--- a/src/pgtkterm.h
+++ b/src/pgtkterm.h
@@ -450,6 +450,9 @@ #define BLUE_FROM_ULONG(color)	((color) & 0xff)
      I watch it periodically with atimer. */
   double watched_scale_factor;
   struct atimer *scale_factor_atimer;
+
+  /* Cursor animation data */
+  struct pgtk_cursor_animation_data *cursor_animation_data;
 };
 
 /* Satisfy term.c.  */
