diff --git a/src/nsterm.h b/src/nsterm.h
index 6a715fb92fc..19e87be0b7c 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -461,6 +461,8 @@ #define NSTRACE_UNSILENCE()
 
 @class EmacsToolbar;
 @class EmacsLayer;
+@class CALayer;
+@class CATextLayer;
 
 #ifdef NS_IMPL_COCOA
 @interface EmacsView : NSView <NSTextInput, NSTextInputClient, NSWindowDelegate>
@@ -471,6 +473,13 @@ #define NSTRACE_UNSILENCE()
 #ifdef NS_IMPL_COCOA
   char *old_title;
   BOOL maximizing_resize;
+  NSView  *cursorOverlayView;   /* 与 EmacsView 同坐标系（左上为原点） */
+  CALayer *cursorLayer;         /* 真正绘制"光标块"的 CA 子层 */
+  CATextLayer *cursorTextLayer; /* 光标上显示的文字层 */
+  BOOL cursorLayerVisible;
+  NSRect  cursorLayerLastFrame;   /* 上次目标 frame，用于抑制重复动画 */
+  BOOL    cursorLayerLastValid;   /* 是否已有有效的上次目标 */
+  CFTimeInterval lastMoveT;
 #endif
   BOOL font_panel_active;
   NSFont *font_panel_result;
@@ -505,6 +514,23 @@ #define NSTRACE_UNSILENCE()
 - (void) toggleFullScreen: (id) sender;
 - (BOOL) fsIsNative;
 - (BOOL) isFullscreen;
+
+#ifdef NS_IMPL_COCOA
+- (void)ensureCursorOverlayAndLayer;
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window
+                    cursorType:(enum text_cursor_kinds)cursor_type
+                   glyphString:(NSString *)glyphStr
+                          font:(NSFont *)font
+                 characterFace:(struct face *)face;
+- (void)hideCursorLayer;
+- (BOOL)cursorLayerIsVisible;
+#endif
+
 #if defined (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
 - (void) updateCollectionBehavior;
 #endif
diff --git a/src/nsterm.m b/src/nsterm.m
index 472d2a52a7d..941f66164bb 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -72,6 +72,12 @@ Updated by Christian Limpach (chris@nice.ch)
 #include "macfont.h"
 #include <Carbon/Carbon.h>
 #include <IOSurface/IOSurface.h>
+#import <QuartzCore/QuartzCore.h>   /* CALayer, CABasicAnimation, CAMediaTimingFunction */
+#include "lisp.h"
+#include "frame.h"
+static const CGFloat MOVE_ON_EPS  = 0.35;   // 开始移动阈值（像素）
+static const CGFloat MOVE_OFF_EPS = 0.20;   // 结束移动阈值（像素）
+static const CFTimeInterval MOVING_GRACE_S = 0.12; // 停止后的宽限期
 #endif
 
 static EmacsMenu *dockMenu;
@@ -3190,6 +3196,160 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   /* Prevent the cursor from being drawn outside the text area.  */
   r = NSIntersectionRect (r, ns_row_rect (w, glyph_row, TEXT_AREA));
 
+/* ---------- Cursor overlay (neo-style; glyph-box correct; pixel-snapped; animated) ---------- */
+#ifdef NS_IMPL_COCOA
+  {
+    EmacsView *view = FRAME_NS_VIEW (f);
+    if (view && [view window])
+      {
+        if (![view wantsLayer]) [view setWantsLayer:YES];
+
+        /* 仅允许“活动 frame + 被选中 window”驱动 overlay，避免多 window 抢层 */
+        bool is_selected_win = (w == XWINDOW (FRAME_SELECTED_WINDOW (f)));
+        BOOL overlay_ctx_ok = (active_p && is_selected_win);
+
+        /* 1) 用"当前 glyph 盒子"重建 r 的高度 —— 避免 box 光标使用整行高 */
+        /* 但保留 HBAR/BAR 光标的原始高度（可能被 evil-half-cursor 等修改）*/
+        if (cursor_type == FILLED_BOX_CURSOR || cursor_type == HOLLOW_BOX_CURSOR)
+        {
+          int used = glyph_row->used[TEXT_AREA];
+          int hpos = w->phys_cursor.hpos;
+          if (!glyph_row->reversed_p && hpos < 0)           hpos = 0;
+          if ( glyph_row->reversed_p && hpos >= used)       hpos = used - 1;
+
+          if (hpos >= 0 && hpos < used)
+            {
+              struct glyph *g = &glyph_row->glyphs[TEXT_AREA][hpos];
+              int asc = g->ascent;
+              int dsc = g->descent;
+              int glyph_h_px = asc + dsc;
+              if (glyph_h_px < 1) glyph_h_px = 1;
+              // 对于 BOX 光标，使用精确的 glyph 高度而不是整行高度
+              r.size.height = glyph_h_px;
+              // r.origin.y 保持不动（我们使用顶部锚点/翻转几何时即为"以顶为准"）
+            }
+        }
+
+        /* 2) 设备 scale 与像素对齐 */
+        CGFloat scale = view.window.screen ? view.window.screen.backingScaleFactor : 1.0;
+        NSRect fr = r;
+        fr.origin.x    = floor((fr.origin.x  * scale) + 0.5) / scale;
+        fr.origin.y    = floor((fr.origin.y  * scale) + 0.5) / scale;
+        fr.size.width  = fmax(1.0, floor((fr.size.width  * scale) + 0.5) / scale);
+        fr.size.height = fmax(1.0, floor((fr.size.height * scale) + 0.5) / scale);
+
+        /* 3) 颜色与圆角：bar/hbar 为 0，box 可给轻微圆角 */
+        NSColor *ccolor = FRAME_CURSOR_COLOR (f);
+        CGFloat corner = 0.0;
+        switch (cursor_type)
+          {
+          case BAR_CURSOR:  corner = 0.0; break;
+          case HBAR_CURSOR: corner = 0.0; break;
+          default:          corner = 1.5; break; /* box */
+          }
+
+        /* 获取光标下的字符和字体信息 */
+        NSString *glyphStr = nil;
+        NSFont *cursorFont = nil;
+        struct face *cursorFace = NULL;
+
+        if (cursor_type == FILLED_BOX_CURSOR && phys_cursor_glyph) {
+          /* 获取字符 */
+          if (phys_cursor_glyph->type == CHAR_GLYPH) {
+            int c = phys_cursor_glyph->u.ch;
+            if (c > 0 && c < 0x110000) {  /* 有效的 Unicode 字符 */
+              unichar uc = (unichar)c;
+              if (c < 0x10000) {
+                glyphStr = [NSString stringWithCharacters:&uc length:1];
+              } else {
+                /* 处理 surrogate pairs (emoji 等) */
+                unichar chars[2];
+                c -= 0x10000;
+                chars[0] = 0xD800 + (c >> 10);
+                chars[1] = 0xDC00 + (c & 0x3FF);
+                glyphStr = [NSString stringWithCharacters:chars length:2];
+              }
+            }
+          }
+
+          /* 获取字体 */
+          int face_id = phys_cursor_glyph->face_id;
+          cursorFace = FACE_FROM_ID_OR_NULL (f, face_id);
+          if (cursorFace && cursorFace->font) {
+#ifdef NS_IMPL_GNUSTEP
+            struct nsfont_info *font_info = (struct nsfont_info *)cursorFace->font;
+            if (font_info && font_info->nsfont)
+              cursorFont = font_info->nsfont;
+#else
+            cursorFont = (NSFont *)macfont_get_nsctfont (cursorFace->font);
+#endif
+          }
+
+          /* 回退到 frame 默认字体 */
+          if (!cursorFont) {
+            struct font *frame_font = FRAME_OUTPUT_DATA (f)->font;
+            if (frame_font) {
+#ifdef NS_IMPL_GNUSTEP
+              struct nsfont_info *font_info = (struct nsfont_info *)frame_font;
+              if (font_info && font_info->nsfont)
+                cursorFont = font_info->nsfont;
+#else
+              cursorFont = (NSFont *)macfont_get_nsctfont (frame_font);
+#endif
+            }
+          }
+        }
+
+        /* 4) 更新 overlay（overlay 根层 geometryFlipped = YES，避免 tab-bar 触发 y 偏移） */
+        [view updateCursorLayerFrame:fr
+                               scale:(scale > 0 ? scale : 1.0)
+                               color:ccolor
+                        cornerRadius:corner
+                             onState:on_p
+                            activeWL:overlay_ctx_ok
+                          cursorType:cursor_type
+                         glyphString:glyphStr
+                                font:cursorFont
+                       characterFace:cursorFace];
+        /* 只在 CA 层不可见（未移动/已就位）时回退绘制原始光标，避免遮挡文本 */
+        if (![view cursorLayerIsVisible])
+          {
+            ns_focus (f, NULL, 0);
+
+            NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+            [ctx saveGraphicsState];
+            NSRectClip (r);
+
+            [FRAME_CURSOR_COLOR (f) set];
+
+            switch (cursor_type)
+              {
+              case DEFAULT_CURSOR:
+              case NO_CURSOR:
+                break;
+              case FILLED_BOX_CURSOR:
+                [ctx restoreGraphicsState];
+                ns_unfocus (f);
+                draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
+                ns_focus (f, &r, 1);
+                break;
+              case HOLLOW_BOX_CURSOR:
+                [NSBezierPath strokeRect: NSInsetRect (r, 0.5, 0.5)];
+                [ctx restoreGraphicsState];
+                break;
+              case HBAR_CURSOR:
+              case BAR_CURSOR:
+                NSRectFill (r);
+                [ctx restoreGraphicsState];
+                break;
+              }
+
+            ns_unfocus (f);
+          }
+      }
+  }
+#else
+  /* GNUstep: 回退到原有绘制（无动画）。保留最小可用实现。 */
   ns_focus (f, NULL, 0);
 
   NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
@@ -3228,6 +3388,7 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
     }
 
   ns_unfocus (f);
+#endif /* NS_IMPL_COCOA */
 }
 
 
@@ -6830,6 +6991,307 @@ - (void)windowDidEndLiveResize:(NSNotification *)notification
   [self updateFramePosition];
 }
 
+/* === Cursor overlay helpers =================================== */
+- (void)ensureCursorOverlayAndLayer
+{
+  if (cursorOverlayView == nil)
+    {
+      NSView *ov = [[NSView alloc] initWithFrame:self.bounds];
+      [ov setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
+      [ov setWantsLayer:YES];
+
+      CALayer *root = [CALayer layer];
+      /* 关键：让 CA 坐标与 EmacsView 一致（左上为原点），避免 tab-bar/tool-bar 造成的 y 偏移 */
+      root.geometryFlipped = NO;
+      root.masksToBounds   = NO;
+#ifdef NSAppKitVersionNumber10_14
+      root.contentsFormat  = kCAContentsFormatRGBA8Uint;
+#endif
+      ov.layer = root;
+
+      CALayer *cl = [CALayer layer];
+      cl.anchorPoint = CGPointZero;          /* 用 frame 放置 */
+      cl.masksToBounds = YES;
+
+      CGFloat scale = self.window.screen ? self.window.screen.backingScaleFactor : 1.0;
+      cl.contentsScale = (scale > 0 ? scale : 1.0);
+
+      /* 关闭隐式动画，转而在“确实移动时”手动加动画（平滑移动） */
+      NSMutableDictionary *acts = [NSMutableDictionary dictionary];
+      [acts setObject:[NSNull null] forKey:@"position"];
+      [acts setObject:[NSNull null] forKey:@"bounds"];
+      [acts setObject:[NSNull null] forKey:@"opacity"];
+      cl.actions = acts;
+
+      [root addSublayer:cl];
+
+      cursorOverlayView = ov;      /* MRC：不使用 __weak */
+      cursorLayer       = cl;
+      cl.opacity = 0.0f;          /* 初始隐藏 CA 光标 */
+      cursorLayerVisible = NO;    /* 初始不占位，不抑制原始绘制 */
+      cursorLayerLastValid = NO;
+
+      [self addSubview:cursorOverlayView];   /* 置于最上层 */
+      [ov release];
+      /* cl 由 root 持有，不需额外 retain */
+    }
+  else
+    {
+      if (![cursorOverlayView wantsLayer])
+        [cursorOverlayView setWantsLayer:YES];
+      if (cursorOverlayView.layer && !cursorOverlayView.layer.geometryFlipped)
+        cursorOverlayView.layer.geometryFlipped = YES;
+    }
+}
+
+- (void)hideCursorLayer
+{
+  if (cursorLayer)
+    {
+      cursorLayer.opacity = 0.0f;
+    }
+  if (cursorTextLayer)
+    {
+      [cursorTextLayer removeFromSuperlayer];
+      cursorTextLayer = nil;
+    }
+  cursorLayerVisible = NO;
+  cursorLayerLastValid = NO; /* 防止旧缓存让下一帧被误判为"在动" */
+}
+
+/* ---------- 方案 B：回落到原生绘制时重置闪烁 ---------- */
+/* 尝试调用 (blink-cursor--reset)：
+   - 语义：立刻点亮光标，并将“下一次开始闪”的计时从头计算；
+   - 只有当该符号存在且可调用时才调用；
+   - 否则返回 false，让上层采用兜底策略（“强制亮一帧”）。 */
+static bool
+ns_try_call_blink_reset_lisp (void)
+{
+  /* intern_c_string: C 字符串 -> Lisp 符号；Fboundp: 是否有函数定义 */
+  Lisp_Object sym = intern_c_string ("blink-cursor--reset");
+  if (!NILP (Fboundp (sym)))
+    {
+      /* call0: 无参调用。等价于 (blink-cursor--reset) */
+      Ffuncall (1, &sym);
+      return true;
+    }
+  return false;
+}
+
+/* 外部可调用的“小重置钩子”：优先用 Lisp 的 reset；
+   若缺失，则返回 false 让调用方做兜底（保亮一帧）。 */
+static bool
+ns_reset_blink_cursor_for_fallback (void)
+{
+  /* 如果能找到并调用 blink-cursor--reset，就用它（最佳语义）。 */
+  if (ns_try_call_blink_reset_lisp ())
+    return true;
+  /* 没有该符号（不同版本/配置）则交由调用点做 minimal 兜底。 */
+  return false;
+}
+
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window
+                    cursorType:(enum text_cursor_kinds)cursor_type
+                   glyphString:(NSString *)glyphStr
+                          font:(NSFont *)font
+                 characterFace:(struct face *)face
+{
+  [self ensureCursorOverlayAndLayer];
+
+  CALayer *root  = cursorOverlayView.layer;
+  CALayer *layer = cursorLayer;
+
+  /* —— 抗抖参数 —— */
+  static const CGFloat MOVE_ON_EPS  = 0.35;
+  static const CGFloat MOVE_OFF_EPS = 0.20;
+  static const CFTimeInterval MOVING_GRACE_S = 0.12;
+
+  static CFTimeInterval s_lastMoveT = 0.0;
+
+  if (!is_active_selected_window) {
+    [self hideCursorLayer];
+    return;
+  }
+
+  /* 外观同步 - 处理 HOLLOW vs FILLED 光标 */
+  if (cursor_type == HOLLOW_BOX_CURSOR) {
+    /* HOLLOW 光标：透明背景 + 边框 */
+    layer.backgroundColor = [[NSColor clearColor] CGColor];
+    layer.borderColor = color.CGColor;
+    layer.borderWidth = 1.0;
+  } else {
+    /* FILLED 光标：正常背景 + 无边框 */
+    layer.backgroundColor = color.CGColor;
+    layer.borderWidth = 0.0;
+  }
+  layer.cornerRadius = radius;
+
+  /* 更新或创建 CATextLayer 显示光标下的字符 */
+  if (glyphStr && [glyphStr length] > 0 && cursor_type == FILLED_BOX_CURSOR) {
+    if (!cursorTextLayer) {
+      cursorTextLayer = [CATextLayer layer];
+      cursorTextLayer.anchorPoint = CGPointZero;
+
+      /* 关闭隐式动画 */
+      NSMutableDictionary *acts = [NSMutableDictionary dictionary];
+      [acts setObject:[NSNull null] forKey:@"position"];
+      [acts setObject:[NSNull null] forKey:@"bounds"];
+      [acts setObject:[NSNull null] forKey:@"foregroundColor"];
+      [acts setObject:[NSNull null] forKey:@"contents"];
+      cursorTextLayer.actions = acts;
+
+      [layer addSublayer:cursorTextLayer];
+    }
+
+    /* 设置文字内容 */
+    cursorTextLayer.string = glyphStr;
+    cursorTextLayer.font = (__bridge CFTypeRef)font;
+    cursorTextLayer.fontSize = [font pointSize];
+
+    /* 智能文字颜色选择（参考 X11 xterm.c:8335-8351）*/
+    struct frame *f = *emacsframe;
+    NSColor *textColor = nil;
+    unsigned long cursorBgColor = [color unsignedLong];
+
+    if (face) {
+      /* 1. 优先使用字符原背景色（保留原色效果）*/
+      textColor = [NSColor colorWithUnsignedLong:face->background];
+      unsigned long textColorVal = [textColor unsignedLong];
+
+      /* 2. 如果文字颜色与光标背景色相同（看不清），尝试用前景色 */
+      if (textColorVal == cursorBgColor) {
+        textColor = [NSColor colorWithUnsignedLong:face->foreground];
+        textColorVal = [textColor unsignedLong];
+      }
+
+      /* 3. 如果还是看不清，使用 frame 背景色（反色）*/
+      if (textColorVal == cursorBgColor) {
+        textColor = FRAME_BACKGROUND_COLOR (f);
+      }
+    } else {
+      /* 无 face 信息时，回退到 frame 背景色 */
+      textColor = FRAME_BACKGROUND_COLOR (f);
+    }
+
+    cursorTextLayer.foregroundColor = [textColor CGColor];
+    cursorTextLayer.contentsScale = scale;
+    cursorTextLayer.alignmentMode = kCAAlignmentCenter;
+
+    /* 设置文字层的位置和大小与光标层一致 */
+    cursorTextLayer.position = CGPointZero;
+    cursorTextLayer.bounds = CGRectMake(0, 0, fr.size.width, fr.size.height);
+  } else {
+    /* HOLLOW 光标或无字符时隐藏文字层 */
+    if (cursorTextLayer) {
+      [cursorTextLayer removeFromSuperlayer];
+      cursorTextLayer = nil;
+    }
+  }
+
+  /* 坐标→像素对齐 */
+  CGFloat H_view = NSHeight(self.bounds);
+  fr.origin.y = H_view - fr.size.height - fr.origin.y;
+
+  CGFloat s = (scale > 0 ? scale : 1.0);
+  fr.origin.x    = floor((fr.origin.x  * s) + 0.5) / s;
+  fr.origin.y    = floor((fr.origin.y  * s) + 0.5) / s;
+  fr.size.width  = fmax(1.0, floor((fr.size.width  * s) + 0.5) / s);
+  fr.size.height = fmax(1.0, floor((fr.size.height * s) + 0.5) / s);
+
+  root.contentsScale  = s;
+  layer.contentsScale = s;
+
+  /* 与上一帧差异 */
+  CGFloat dx = fabs(fr.origin.x - cursorLayerLastFrame.origin.x);
+  CGFloat dy = fabs(fr.origin.y - cursorLayerLastFrame.origin.y);
+  CGFloat dw = fabs(fr.size.width  - cursorLayerLastFrame.size.width);
+  CGFloat dh = fabs(fr.size.height - cursorLayerLastFrame.size.height);
+
+  BOOL move_delta_big   = (dx > MOVE_ON_EPS)  || (dy > MOVE_ON_EPS)  ||
+                          (dw > MOVE_ON_EPS)  || (dh > MOVE_ON_EPS);
+  BOOL move_delta_small = (dx < MOVE_OFF_EPS) && (dy < MOVE_OFF_EPS) &&
+                          (dw < MOVE_OFF_EPS) && (dh < MOVE_OFF_EPS);
+
+  CFTimeInterval now = CACurrentMediaTime();
+  BOOL moving;
+  if (!cursorLayerLastValid)      moving = YES;
+  else if (move_delta_big)        moving = YES;
+  else if (move_delta_small)      moving = (now - s_lastMoveT) < MOVING_GRACE_S;
+  else                            moving = cursorLayerVisible;
+
+  if (moving) s_lastMoveT = now;
+
+  /* ================= 移动态：忽略 blink，相位始终亮 ================= */
+  if (moving) {
+    /* 初次变可见：一次性淡入 */
+    if (!cursorLayerVisible) {
+      cursorLayerVisible = YES;
+      layer.opacity = 1.0;
+      CABasicAnimation *fade = [CABasicAnimation animationWithKeyPath:@"opacity"];
+      fade.fromValue = @(0.0);
+      fade.toValue   = @(1.0);
+      fade.duration  = 0.06;
+      fade.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+      [layer addAnimation:fade forKey:@"cursorFadeInOnce"];
+    }
+
+    /* —— 始终做位移/尺寸动画（无大跳变特判）—— */
+    /* 先把最终值写入 model layer */
+    layer.position = fr.origin;
+    layer.bounds   = (CGRect){ .origin={0,0}, .size=fr.size };
+
+    /* 只要有几何变化就加动画；无变化则不必加（避免堆积） */
+    if ((dx + dy + dw + dh) > 0.0) {
+      CALayer *pres = (CALayer *)layer.presentationLayer;
+
+      /* position 动画 */
+      CABasicAnimation *pos = [CABasicAnimation animationWithKeyPath:@"position"];
+      pos.fromValue = pres ? [NSValue valueWithPoint:NSPointFromCGPoint(((CALayer *)pres).position)]
+                           : [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.toValue   = [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.duration  = 0.10;
+      pos.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* bounds 动画（尺寸变化） */
+      CABasicAnimation *bd = [CABasicAnimation animationWithKeyPath:@"bounds"];
+      bd.fromValue = pres ? [NSValue valueWithRect:NSRectFromCGRect(((CALayer *)pres).bounds)]
+                          : [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.toValue   = [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.duration  = 0.10;
+      bd.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* 覆盖同类动画，避免堆积 */
+      [layer addAnimation:pos forKey:@"cursorMovePosition"];
+      [layer addAnimation:bd  forKey:@"cursorMoveBounds"];
+    }
+
+    cursorLayerLastFrame = fr;
+    cursorLayerLastValid = YES;
+    return; /* 移动态不走原生绘制，避免双影 */
+  }
+
+  /* ================= 静止：交回原生闪烁 ================= */
+  layer.opacity       = 0.0;
+  cursorLayerVisible  = NO;
+  if (cursorTextLayer) {
+    [cursorTextLayer removeFromSuperlayer];
+    cursorTextLayer = nil;
+  }
+  cursorLayerLastFrame = fr;
+  cursorLayerLastValid = YES;
+}
+
+- (BOOL)cursorLayerIsVisible
+{
+  return cursorLayerVisible;
+}
+/* ========================================================================== */
+
 /* Needed to inform when window closed from lisp.  */
 - (void) setWindowClosing: (BOOL)closing
 {
