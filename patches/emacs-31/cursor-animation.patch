diff --git a/src/nsterm.h b/src/nsterm.h
index 6a715fb92fc..9d845f0fd96 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -471,6 +471,12 @@ #define NSTRACE_UNSILENCE()
 #ifdef NS_IMPL_COCOA
   char *old_title;
   BOOL maximizing_resize;
+  NSView  *cursorOverlayView;   /* 与 EmacsView 同坐标系（左上为原点） */
+  CALayer *cursorLayer;         /* 真正绘制“光标块”的 CA 子层 */
+  BOOL cursorLayerVisible;
+  NSRect  cursorLayerLastFrame;   /* 上次目标 frame，用于抑制重复动画 */
+  BOOL    cursorLayerLastValid;   /* 是否已有有效的上次目标 */
+  CFTimeInterval lastMoveT;
 #endif
   BOOL font_panel_active;
   NSFont *font_panel_result;
@@ -505,6 +511,19 @@ #define NSTRACE_UNSILENCE()
 - (void) toggleFullScreen: (id) sender;
 - (BOOL) fsIsNative;
 - (BOOL) isFullscreen;
+
+#ifdef NS_IMPL_COCOA
+- (void)ensureCursorOverlayAndLayer;
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window;
+- (void)hideCursorLayer;
+- (BOOL)cursorLayerIsVisible;
+#endif
+
 #if defined (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
 - (void) updateCollectionBehavior;
 #endif
diff --git a/src/nsterm.m b/src/nsterm.m
index 472d2a52a7d..fe400500c8e 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -72,6 +72,12 @@ Updated by Christian Limpach (chris@nice.ch)
 #include "macfont.h"
 #include <Carbon/Carbon.h>
 #include <IOSurface/IOSurface.h>
+#import <QuartzCore/QuartzCore.h>   /* CALayer, CABasicAnimation, CAMediaTimingFunction */
+#include "lisp.h"
+#include "frame.h"
+static const CGFloat MOVE_ON_EPS  = 0.35;   // 开始移动阈值（像素）
+static const CGFloat MOVE_OFF_EPS = 0.20;   // 结束移动阈值（像素）
+static const CFTimeInterval MOVING_GRACE_S = 0.12; // 停止后的宽限期
 #endif
 
 static EmacsMenu *dockMenu;
@@ -3190,6 +3196,112 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   /* Prevent the cursor from being drawn outside the text area.  */
   r = NSIntersectionRect (r, ns_row_rect (w, glyph_row, TEXT_AREA));
 
+/* ---------- Cursor overlay (neo-style; glyph-box correct; pixel-snapped; animated) ---------- */
+#ifdef NS_IMPL_COCOA
+  {
+    EmacsView *view = FRAME_NS_VIEW (f);
+    if (view && [view window])
+      {
+        if (![view wantsLayer]) [view setWantsLayer:YES];
+
+        /* 仅允许“活动 frame + 被选中 window”驱动 overlay，避免多 window 抢层 */
+        bool is_selected_win = (w == XWINDOW (FRAME_SELECTED_WINDOW (f)));
+        BOOL overlay_ctx_ok = (active_p && is_selected_win);
+
+        /* 1) 用“当前 glyph 盒子”重建 r 的高度 —— 避免 box 光标使用整行高 */
+        {
+          int used = glyph_row->used[TEXT_AREA];
+          int hpos = w->phys_cursor.hpos;
+          if (!glyph_row->reversed_p && hpos < 0)           hpos = 0;
+          if ( glyph_row->reversed_p && hpos >= used)       hpos = used - 1;
+
+          if (hpos >= 0 && hpos < used)
+            {
+              struct glyph *g = &glyph_row->glyphs[TEXT_AREA][hpos];
+              int asc = g->ascent;
+              int dsc = g->descent;
+              int glyph_h_px = asc + dsc;
+              if (glyph_h_px < 1) glyph_h_px = 1;
+              // Preserve hbar (underline) as a thin, bottom-aligned strip.
+              // 经验阈值：如果传入的 r 本就是“很薄”的（相对字形高度），判为 hbar。
+              CGFloat orig_h = r.size.height;            // 这是前面已为不同光标类型算好的高度
+              if (orig_h > glyph_h_px * 0.40) {
+                // box/hollow 这类：按 glyph 高度重建
+                r.size.height = glyph_h_px;
+                // r.origin.y 保持不动（我们使用顶部锚点/翻转几何时即为“以顶为准”）
+              } else {
+                // hbar：维持细条，并保证“贴底”
+                CGFloat bottom_y = NSMaxY(r);
+                r.size.height = MAX(1.0, orig_h);
+                r.origin.y = bottom_y - r.size.height;
+              }
+            }
+        }
+
+        /* 2) 设备 scale 与像素对齐 */
+        CGFloat scale = view.window.screen ? view.window.screen.backingScaleFactor : 1.0;
+        NSRect fr = r;
+        fr.origin.x    = floor((fr.origin.x  * scale) + 0.5) / scale;
+        fr.origin.y    = floor((fr.origin.y  * scale) + 0.5) / scale;
+        fr.size.width  = fmax(1.0, floor((fr.size.width  * scale) + 0.5) / scale);
+        fr.size.height = fmax(1.0, floor((fr.size.height * scale) + 0.5) / scale);
+
+        /* 3) 颜色与圆角：bar/hbar 为 0，box 可给轻微圆角 */
+        NSColor *ccolor = FRAME_CURSOR_COLOR (f);
+        CGFloat corner = 0.0;
+        switch (cursor_type)
+          {
+          case BAR_CURSOR:  corner = 0.0; break;
+          case HBAR_CURSOR: corner = 0.0; break;
+          default:          corner = 1.5; break; /* box */
+          }
+
+        /* 4) 更新 overlay（overlay 根层 geometryFlipped = YES，避免 tab-bar 触发 y 偏移） */
+        [view updateCursorLayerFrame:fr
+                               scale:(scale > 0 ? scale : 1.0)
+                               color:ccolor
+                        cornerRadius:corner
+                             onState:on_p
+                            activeWL:overlay_ctx_ok];
+        /* 只在 CA 层不可见（未移动/已就位）时回退绘制原始光标，避免遮挡文本 */
+        if (![view cursorLayerIsVisible])
+          {
+            ns_focus (f, NULL, 0);
+
+            NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+            [ctx saveGraphicsState];
+            NSRectClip (r);
+
+            [FRAME_CURSOR_COLOR (f) set];
+
+            switch (cursor_type)
+              {
+              case DEFAULT_CURSOR:
+              case NO_CURSOR:
+                break;
+              case FILLED_BOX_CURSOR:
+                [ctx restoreGraphicsState];
+                ns_unfocus (f);
+                draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
+                ns_focus (f, &r, 1);
+                break;
+              case HOLLOW_BOX_CURSOR:
+                [NSBezierPath strokeRect: NSInsetRect (r, 0.5, 0.5)];
+                [ctx restoreGraphicsState];
+                break;
+              case HBAR_CURSOR:
+              case BAR_CURSOR:
+                NSRectFill (r);
+                [ctx restoreGraphicsState];
+                break;
+              }
+
+            ns_unfocus (f);
+          }
+      }
+  }
+#else
+  /* GNUstep: 回退到原有绘制（无动画）。保留最小可用实现。 */
   ns_focus (f, NULL, 0);
 
   NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
@@ -3228,6 +3340,7 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
     }
 
   ns_unfocus (f);
+#endif /* NS_IMPL_COCOA */
 }
 
 
@@ -6830,6 +6943,223 @@ - (void)windowDidEndLiveResize:(NSNotification *)notification
   [self updateFramePosition];
 }
 
+/* === Cursor overlay helpers =================================== */
+- (void)ensureCursorOverlayAndLayer
+{
+  if (cursorOverlayView == nil)
+    {
+      NSView *ov = [[NSView alloc] initWithFrame:self.bounds];
+      [ov setAutoresizingMask:(NSViewWidthSizable | NSViewHeightSizable)];
+      [ov setWantsLayer:YES];
+
+      CALayer *root = [CALayer layer];
+      /* 关键：让 CA 坐标与 EmacsView 一致（左上为原点），避免 tab-bar/tool-bar 造成的 y 偏移 */
+      root.geometryFlipped = NO;
+      root.masksToBounds   = NO;
+#ifdef NSAppKitVersionNumber10_14
+      root.contentsFormat  = kCAContentsFormatRGBA8Uint;
+#endif
+      ov.layer = root;
+
+      CALayer *cl = [CALayer layer];
+      cl.anchorPoint = CGPointZero;          /* 用 frame 放置 */
+      cl.masksToBounds = YES;
+
+      CGFloat scale = self.window.screen ? self.window.screen.backingScaleFactor : 1.0;
+      cl.contentsScale = (scale > 0 ? scale : 1.0);
+
+      /* 关闭隐式动画，转而在“确实移动时”手动加动画（平滑移动） */
+      NSMutableDictionary *acts = [NSMutableDictionary dictionary];
+      [acts setObject:[NSNull null] forKey:@"position"];
+      [acts setObject:[NSNull null] forKey:@"bounds"];
+      [acts setObject:[NSNull null] forKey:@"opacity"];
+      cl.actions = acts;
+
+      [root addSublayer:cl];
+
+      cursorOverlayView = ov;      /* MRC：不使用 __weak */
+      cursorLayer       = cl;
+      cl.opacity = 0.0f;          /* 初始隐藏 CA 光标 */
+      cursorLayerVisible = NO;    /* 初始不占位，不抑制原始绘制 */
+      cursorLayerLastValid = NO;
+
+      [self addSubview:cursorOverlayView];   /* 置于最上层 */
+      [ov release];
+      /* cl 由 root 持有，不需额外 retain */
+    }
+  else
+    {
+      if (![cursorOverlayView wantsLayer])
+        [cursorOverlayView setWantsLayer:YES];
+      if (cursorOverlayView.layer && !cursorOverlayView.layer.geometryFlipped)
+        cursorOverlayView.layer.geometryFlipped = YES;
+    }
+}
+
+- (void)hideCursorLayer
+{
+  if (cursorLayer)
+    {
+      cursorLayer.opacity = 0.0f;
+    }
+  cursorLayerVisible = NO;
+  cursorLayerLastValid = NO; /* 防止旧缓存让下一帧被误判为“在动” */
+}
+
+/* ---------- 方案 B：回落到原生绘制时重置闪烁 ---------- */
+/* 尝试调用 (blink-cursor--reset)：
+   - 语义：立刻点亮光标，并将“下一次开始闪”的计时从头计算；
+   - 只有当该符号存在且可调用时才调用；
+   - 否则返回 false，让上层采用兜底策略（“强制亮一帧”）。 */
+static bool
+ns_try_call_blink_reset_lisp (void)
+{
+  /* intern_c_string: C 字符串 -> Lisp 符号；Fboundp: 是否有函数定义 */
+  Lisp_Object sym = intern_c_string ("blink-cursor--reset");
+  if (!NILP (Fboundp (sym)))
+    {
+      /* call0: 无参调用。等价于 (blink-cursor--reset) */
+      Ffuncall (1, &sym);
+      return true;
+    }
+  return false;
+}
+
+/* 外部可调用的“小重置钩子”：优先用 Lisp 的 reset；
+   若缺失，则返回 false 让调用方做兜底（保亮一帧）。 */
+static bool
+ns_reset_blink_cursor_for_fallback (void)
+{
+  /* 如果能找到并调用 blink-cursor--reset，就用它（最佳语义）。 */
+  if (ns_try_call_blink_reset_lisp ())
+    return true;
+  /* 没有该符号（不同版本/配置）则交由调用点做 minimal 兜底。 */
+  return false;
+}
+
+- (void)updateCursorLayerFrame:(NSRect)fr
+                         scale:(CGFloat)scale
+                         color:(NSColor *)color
+                  cornerRadius:(CGFloat)radius
+                       onState:(BOOL)on_p
+                      activeWL:(BOOL)is_active_selected_window
+{
+  [self ensureCursorOverlayAndLayer];
+
+  CALayer *root  = cursorOverlayView.layer;
+  CALayer *layer = cursorLayer;
+
+  /* —— 抗抖参数 —— */
+  static const CGFloat MOVE_ON_EPS  = 0.35;
+  static const CGFloat MOVE_OFF_EPS = 0.20;
+  static const CFTimeInterval MOVING_GRACE_S = 0.12;
+
+  static CFTimeInterval s_lastMoveT = 0.0;
+
+  if (!is_active_selected_window) {
+    [self hideCursorLayer];
+    return;
+  }
+
+  /* 外观同步 */
+  layer.backgroundColor = color.CGColor;
+  layer.cornerRadius    = radius;
+
+  /* 坐标→像素对齐 */
+  CGFloat H_view = NSHeight(self.bounds);
+  fr.origin.y = H_view - fr.size.height - fr.origin.y;
+
+  CGFloat s = (scale > 0 ? scale : 1.0);
+  fr.origin.x    = floor((fr.origin.x  * s) + 0.5) / s;
+  fr.origin.y    = floor((fr.origin.y  * s) + 0.5) / s;
+  fr.size.width  = fmax(1.0, floor((fr.size.width  * s) + 0.5) / s);
+  fr.size.height = fmax(1.0, floor((fr.size.height * s) + 0.5) / s);
+
+  root.contentsScale  = s;
+  layer.contentsScale = s;
+
+  /* 与上一帧差异 */
+  CGFloat dx = fabs(fr.origin.x - cursorLayerLastFrame.origin.x);
+  CGFloat dy = fabs(fr.origin.y - cursorLayerLastFrame.origin.y);
+  CGFloat dw = fabs(fr.size.width  - cursorLayerLastFrame.size.width);
+  CGFloat dh = fabs(fr.size.height - cursorLayerLastFrame.size.height);
+
+  BOOL move_delta_big   = (dx > MOVE_ON_EPS)  || (dy > MOVE_ON_EPS)  ||
+                          (dw > MOVE_ON_EPS)  || (dh > MOVE_ON_EPS);
+  BOOL move_delta_small = (dx < MOVE_OFF_EPS) && (dy < MOVE_OFF_EPS) &&
+                          (dw < MOVE_OFF_EPS) && (dh < MOVE_OFF_EPS);
+
+  CFTimeInterval now = CACurrentMediaTime();
+  BOOL moving;
+  if (!cursorLayerLastValid)      moving = YES;
+  else if (move_delta_big)        moving = YES;
+  else if (move_delta_small)      moving = (now - s_lastMoveT) < MOVING_GRACE_S;
+  else                            moving = cursorLayerVisible;
+
+  if (moving) s_lastMoveT = now;
+
+  /* ================= 移动态：忽略 blink，相位始终亮 ================= */
+  if (moving) {
+    /* 初次变可见：一次性淡入 */
+    if (!cursorLayerVisible) {
+      cursorLayerVisible = YES;
+      layer.opacity = 1.0;
+      CABasicAnimation *fade = [CABasicAnimation animationWithKeyPath:@"opacity"];
+      fade.fromValue = @(0.0);
+      fade.toValue   = @(1.0);
+      fade.duration  = 0.06;
+      fade.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+      [layer addAnimation:fade forKey:@"cursorFadeInOnce"];
+    }
+
+    /* —— 始终做位移/尺寸动画（无大跳变特判）—— */
+    /* 先把最终值写入 model layer */
+    layer.position = fr.origin;
+    layer.bounds   = (CGRect){ .origin={0,0}, .size=fr.size };
+
+    /* 只要有几何变化就加动画；无变化则不必加（避免堆积） */
+    if ((dx + dy + dw + dh) > 0.0) {
+      CALayer *pres = (CALayer *)layer.presentationLayer;
+
+      /* position 动画 */
+      CABasicAnimation *pos = [CABasicAnimation animationWithKeyPath:@"position"];
+      pos.fromValue = pres ? [NSValue valueWithPoint:NSPointFromCGPoint(((CALayer *)pres).position)]
+                           : [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.toValue   = [NSValue valueWithPoint:NSPointFromCGPoint(layer.position)];
+      pos.duration  = 0.10;
+      pos.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* bounds 动画（尺寸变化） */
+      CABasicAnimation *bd = [CABasicAnimation animationWithKeyPath:@"bounds"];
+      bd.fromValue = pres ? [NSValue valueWithRect:NSRectFromCGRect(((CALayer *)pres).bounds)]
+                          : [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.toValue   = [NSValue valueWithRect:NSRectFromCGRect(layer.bounds)];
+      bd.duration  = 0.10;
+      bd.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+
+      /* 覆盖同类动画，避免堆积 */
+      [layer addAnimation:pos forKey:@"cursorMovePosition"];
+      [layer addAnimation:bd  forKey:@"cursorMoveBounds"];
+    }
+
+    cursorLayerLastFrame = fr;
+    cursorLayerLastValid = YES;
+    return; /* 移动态不走原生绘制，避免双影 */
+  }
+
+  /* ================= 静止：交回原生闪烁 ================= */
+  layer.opacity       = 0.0;
+  cursorLayerVisible  = NO;
+  cursorLayerLastFrame = fr;
+  cursorLayerLastValid = YES;
+}
+
+- (BOOL)cursorLayerIsVisible
+{
+  return cursorLayerVisible;
+}
+/* ========================================================================== */
+
 /* Needed to inform when window closed from lisp.  */
 - (void) setWindowClosing: (BOOL)closing
 {
